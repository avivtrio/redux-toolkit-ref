/* tslint:disable */
/* eslint-disable */
/**
 * Smartheart Rest API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { IBasicSmartheartUser } from '../models';
// @ts-ignore
import { IFullSmartheartUser } from '../models';
// @ts-ignore
import { ILoginData } from '../models';
// @ts-ignore
import { IRecipient } from '../models';
// @ts-ignore
import { IShApiResponseBasicSmartheartUser } from '../models';
// @ts-ignore
import { IShApiResponseBoolean } from '../models';
// @ts-ignore
import { IShApiResponseFullSmartheartUser } from '../models';
// @ts-ignore
import { IShApiResponseIEnumerableSmartheartUser } from '../models';
// @ts-ignore
import { IShApiResponseListEcg } from '../models';
// @ts-ignore
import { IShApiResponseListPortalPermission } from '../models';
// @ts-ignore
import { IUserActivationData } from '../models';
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activates a given user based on a valid activation token and sets the given password to the activated user.
         * @param {IUserActivationData} activationData 
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersActivateUser: async (activationData: IUserActivationData, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activationData' is not null or undefined
            assertParamExists('usersActivateUser', 'activationData', activationData)
            const localVarPath = `/users/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activationData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds an additional email recipient for new ECG notifications
         * @param {string} userId The unique identifier of the user to add an additional recipient to
         * @param {IRecipient} recipient The recipient email address
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAddRecipients: async (userId: string, recipient: IRecipient, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersAddRecipients', 'userId', userId)
            // verify required parameter 'recipient' is not null or undefined
            assertParamExists('usersAddRecipients', 'recipient', recipient)
            const localVarPath = `/users/{userId}/recipients`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new user for an organization. The created user needs to be validated and/or activated
         * @param {IBasicSmartheartUser} user The user object to add
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateOrganizationUser: async (user: IBasicSmartheartUser, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersCreateOrganizationUser', 'user', user)
            const localVarPath = `/users/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new user
         * @param {IFullSmartheartUser} user The user object to add
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateUser: async (user: IFullSmartheartUser, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersCreateUser', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes an email recipient for new ECG notifications
         * @param {string} userId The unique identifier of the user to remove the recipient from
         * @param {IRecipient} recipient The recipient email address to remove
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteRecipient: async (userId: string, recipient: IRecipient, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersDeleteRecipient', 'userId', userId)
            // verify required parameter 'recipient' is not null or undefined
            assertParamExists('usersDeleteRecipient', 'recipient', recipient)
            const localVarPath = `/users/{userId}/recipients`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disables the given user
         * @param {string} userId The unique identifier of the user
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDisableUser: async (userId: string, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersDisableUser', 'userId', userId)
            const localVarPath = `/users/{userId}/status`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enables a user
         * @param {string} userId The unique identifier of the user to enable
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersEnableUser: async (userId: string, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersEnableUser', 'userId', userId)
            const localVarPath = `/users/{userId}/status`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the list of ECGs to be viewed in the portal in a given date range of the permissions of the authenticated user.
         * @param {string} userId The unique identifier of the user whose portal ecg list should be returned
         * @param {number} [page] The results \&quot;page\&quot; number to return
         * @param {number} [pageSize] The number of result in each \&quot;page\&quot;
         * @param {string} [fromDate] The date from which to return the ECGs (yyyy-MM-dd)
         * @param {string} [toDate] The date until which to return the ECGs (yyyy-MM-dd)
         * @param {string} [sort] How to sort the returned ecgs list (\&quot;name\&quot; - by the account name, ascending; \&quot;last-ecg\&quot; - by the ecg date/time, descending
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetPortalEcgList: async (userId: string, page?: number, pageSize?: number, fromDate?: string, toDate?: string, sort?: string, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersGetPortalEcgList', 'userId', userId)
            const localVarPath = `/users/{userId}/ecgs`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the list of Smartheart accounts the user has permissions to view in the Smartheart Portal.
         * @param {string} userId The unique identifier of the user whose permissions should be returned
         * @param {number} [page] The results \&quot;page\&quot; number to return
         * @param {number} [pageSize] The number of result in each \&quot;page\&quot;
         * @param {string} [sort] How to sort the returned permissions list (\&quot;name\&quot; - by the account name; \&quot;last-ecg\&quot; - by last ecg date/time
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetPortalPermissions: async (userId: string, page?: number, pageSize?: number, sort?: string, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersGetPortalPermissions', 'userId', userId)
            const localVarPath = `/users/{userId}/permissions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the list of users in the logged api user organization.   Requires Api User role authorization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticates a user
         * @param {ILoginData} credentials The username (email) and password of the user to authenticate
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersLogin: async (credentials: ILoginData, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentials' is not null or undefined
            assertParamExists('usersLogin', 'credentials', credentials)
            const localVarPath = `/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the given user
         * @param {string} userId The unique identifier of the user to update
         * @param {IFullSmartheartUser} user The user data to update
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateUser: async (userId: string, user: IFullSmartheartUser, authorization?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUpdateUser', 'userId', userId)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersUpdateUser', 'user', user)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Activates a given user based on a valid activation token and sets the given password to the activated user.
         * @param {IUserActivationData} activationData 
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersActivateUser(activationData: IUserActivationData, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IShApiResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersActivateUser(activationData, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds an additional email recipient for new ECG notifications
         * @param {string} userId The unique identifier of the user to add an additional recipient to
         * @param {IRecipient} recipient The recipient email address
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAddRecipients(userId: string, recipient: IRecipient, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IShApiResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAddRecipients(userId, recipient, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new user for an organization. The created user needs to be validated and/or activated
         * @param {IBasicSmartheartUser} user The user object to add
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreateOrganizationUser(user: IBasicSmartheartUser, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IShApiResponseBasicSmartheartUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreateOrganizationUser(user, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new user
         * @param {IFullSmartheartUser} user The user object to add
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreateUser(user: IFullSmartheartUser, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IShApiResponseFullSmartheartUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreateUser(user, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Removes an email recipient for new ECG notifications
         * @param {string} userId The unique identifier of the user to remove the recipient from
         * @param {IRecipient} recipient The recipient email address to remove
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDeleteRecipient(userId: string, recipient: IRecipient, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IShApiResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDeleteRecipient(userId, recipient, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Disables the given user
         * @param {string} userId The unique identifier of the user
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDisableUser(userId: string, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IShApiResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDisableUser(userId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Enables a user
         * @param {string} userId The unique identifier of the user to enable
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersEnableUser(userId: string, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IShApiResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersEnableUser(userId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the list of ECGs to be viewed in the portal in a given date range of the permissions of the authenticated user.
         * @param {string} userId The unique identifier of the user whose portal ecg list should be returned
         * @param {number} [page] The results \&quot;page\&quot; number to return
         * @param {number} [pageSize] The number of result in each \&quot;page\&quot;
         * @param {string} [fromDate] The date from which to return the ECGs (yyyy-MM-dd)
         * @param {string} [toDate] The date until which to return the ECGs (yyyy-MM-dd)
         * @param {string} [sort] How to sort the returned ecgs list (\&quot;name\&quot; - by the account name, ascending; \&quot;last-ecg\&quot; - by the ecg date/time, descending
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetPortalEcgList(userId: string, page?: number, pageSize?: number, fromDate?: string, toDate?: string, sort?: string, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IShApiResponseListEcg>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetPortalEcgList(userId, page, pageSize, fromDate, toDate, sort, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the list of Smartheart accounts the user has permissions to view in the Smartheart Portal.
         * @param {string} userId The unique identifier of the user whose permissions should be returned
         * @param {number} [page] The results \&quot;page\&quot; number to return
         * @param {number} [pageSize] The number of result in each \&quot;page\&quot;
         * @param {string} [sort] How to sort the returned permissions list (\&quot;name\&quot; - by the account name; \&quot;last-ecg\&quot; - by last ecg date/time
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetPortalPermissions(userId: string, page?: number, pageSize?: number, sort?: string, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IShApiResponseListPortalPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetPortalPermissions(userId, page, pageSize, sort, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the list of users in the logged api user organization.   Requires Api User role authorization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IShApiResponseIEnumerableSmartheartUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Authenticates a user
         * @param {ILoginData} credentials The username (email) and password of the user to authenticate
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersLogin(credentials: ILoginData, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IShApiResponseFullSmartheartUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersLogin(credentials, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the given user
         * @param {string} userId The unique identifier of the user to update
         * @param {IFullSmartheartUser} user The user data to update
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdateUser(userId: string, user: IFullSmartheartUser, authorization?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IShApiResponseFullSmartheartUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdateUser(userId, user, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Activates a given user based on a valid activation token and sets the given password to the activated user.
         * @param {IUserActivationData} activationData 
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersActivateUser(activationData: IUserActivationData, authorization?: string, options?: any): AxiosPromise<IShApiResponseBoolean> {
            return localVarFp.usersActivateUser(activationData, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds an additional email recipient for new ECG notifications
         * @param {string} userId The unique identifier of the user to add an additional recipient to
         * @param {IRecipient} recipient The recipient email address
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAddRecipients(userId: string, recipient: IRecipient, authorization?: string, options?: any): AxiosPromise<IShApiResponseBoolean> {
            return localVarFp.usersAddRecipients(userId, recipient, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new user for an organization. The created user needs to be validated and/or activated
         * @param {IBasicSmartheartUser} user The user object to add
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateOrganizationUser(user: IBasicSmartheartUser, authorization?: string, options?: any): AxiosPromise<IShApiResponseBasicSmartheartUser> {
            return localVarFp.usersCreateOrganizationUser(user, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new user
         * @param {IFullSmartheartUser} user The user object to add
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateUser(user: IFullSmartheartUser, authorization?: string, options?: any): AxiosPromise<IShApiResponseFullSmartheartUser> {
            return localVarFp.usersCreateUser(user, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes an email recipient for new ECG notifications
         * @param {string} userId The unique identifier of the user to remove the recipient from
         * @param {IRecipient} recipient The recipient email address to remove
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteRecipient(userId: string, recipient: IRecipient, authorization?: string, options?: any): AxiosPromise<IShApiResponseBoolean> {
            return localVarFp.usersDeleteRecipient(userId, recipient, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disables the given user
         * @param {string} userId The unique identifier of the user
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDisableUser(userId: string, authorization?: string, options?: any): AxiosPromise<IShApiResponseBoolean> {
            return localVarFp.usersDisableUser(userId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enables a user
         * @param {string} userId The unique identifier of the user to enable
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersEnableUser(userId: string, authorization?: string, options?: any): AxiosPromise<IShApiResponseBoolean> {
            return localVarFp.usersEnableUser(userId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the list of ECGs to be viewed in the portal in a given date range of the permissions of the authenticated user.
         * @param {string} userId The unique identifier of the user whose portal ecg list should be returned
         * @param {number} [page] The results \&quot;page\&quot; number to return
         * @param {number} [pageSize] The number of result in each \&quot;page\&quot;
         * @param {string} [fromDate] The date from which to return the ECGs (yyyy-MM-dd)
         * @param {string} [toDate] The date until which to return the ECGs (yyyy-MM-dd)
         * @param {string} [sort] How to sort the returned ecgs list (\&quot;name\&quot; - by the account name, ascending; \&quot;last-ecg\&quot; - by the ecg date/time, descending
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetPortalEcgList(userId: string, page?: number, pageSize?: number, fromDate?: string, toDate?: string, sort?: string, authorization?: string, options?: any): AxiosPromise<IShApiResponseListEcg> {
            return localVarFp.usersGetPortalEcgList(userId, page, pageSize, fromDate, toDate, sort, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the list of Smartheart accounts the user has permissions to view in the Smartheart Portal.
         * @param {string} userId The unique identifier of the user whose permissions should be returned
         * @param {number} [page] The results \&quot;page\&quot; number to return
         * @param {number} [pageSize] The number of result in each \&quot;page\&quot;
         * @param {string} [sort] How to sort the returned permissions list (\&quot;name\&quot; - by the account name; \&quot;last-ecg\&quot; - by last ecg date/time
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetPortalPermissions(userId: string, page?: number, pageSize?: number, sort?: string, authorization?: string, options?: any): AxiosPromise<IShApiResponseListPortalPermission> {
            return localVarFp.usersGetPortalPermissions(userId, page, pageSize, sort, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the list of users in the logged api user organization.   Requires Api User role authorization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetUsers(options?: any): AxiosPromise<IShApiResponseIEnumerableSmartheartUser> {
            return localVarFp.usersGetUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticates a user
         * @param {ILoginData} credentials The username (email) and password of the user to authenticate
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersLogin(credentials: ILoginData, authorization?: string, options?: any): AxiosPromise<IShApiResponseFullSmartheartUser> {
            return localVarFp.usersLogin(credentials, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the given user
         * @param {string} userId The unique identifier of the user to update
         * @param {IFullSmartheartUser} user The user data to update
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateUser(userId: string, user: IFullSmartheartUser, authorization?: string, options?: any): AxiosPromise<IShApiResponseFullSmartheartUser> {
            return localVarFp.usersUpdateUser(userId, user, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * 
     * @summary Activates a given user based on a valid activation token and sets the given password to the activated user.
     * @param {IUserActivationData} activationData 
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersActivateUser(activationData: IUserActivationData, authorization?: string, options?: any): AxiosPromise<IShApiResponseBoolean>;

    /**
     * 
     * @summary Adds an additional email recipient for new ECG notifications
     * @param {string} userId The unique identifier of the user to add an additional recipient to
     * @param {IRecipient} recipient The recipient email address
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersAddRecipients(userId: string, recipient: IRecipient, authorization?: string, options?: any): AxiosPromise<IShApiResponseBoolean>;

    /**
     * 
     * @summary Creates a new user for an organization. The created user needs to be validated and/or activated
     * @param {IBasicSmartheartUser} user The user object to add
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersCreateOrganizationUser(user: IBasicSmartheartUser, authorization?: string, options?: any): AxiosPromise<IShApiResponseBasicSmartheartUser>;

    /**
     * 
     * @summary Creates a new user
     * @param {IFullSmartheartUser} user The user object to add
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersCreateUser(user: IFullSmartheartUser, authorization?: string, options?: any): AxiosPromise<IShApiResponseFullSmartheartUser>;

    /**
     * 
     * @summary Removes an email recipient for new ECG notifications
     * @param {string} userId The unique identifier of the user to remove the recipient from
     * @param {IRecipient} recipient The recipient email address to remove
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersDeleteRecipient(userId: string, recipient: IRecipient, authorization?: string, options?: any): AxiosPromise<IShApiResponseBoolean>;

    /**
     * 
     * @summary Disables the given user
     * @param {string} userId The unique identifier of the user
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersDisableUser(userId: string, authorization?: string, options?: any): AxiosPromise<IShApiResponseBoolean>;

    /**
     * 
     * @summary Enables a user
     * @param {string} userId The unique identifier of the user to enable
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersEnableUser(userId: string, authorization?: string, options?: any): AxiosPromise<IShApiResponseBoolean>;

    /**
     * 
     * @summary Gets the list of ECGs to be viewed in the portal in a given date range of the permissions of the authenticated user.
     * @param {string} userId The unique identifier of the user whose portal ecg list should be returned
     * @param {number} [page] The results \&quot;page\&quot; number to return
     * @param {number} [pageSize] The number of result in each \&quot;page\&quot;
     * @param {string} [fromDate] The date from which to return the ECGs (yyyy-MM-dd)
     * @param {string} [toDate] The date until which to return the ECGs (yyyy-MM-dd)
     * @param {string} [sort] How to sort the returned ecgs list (\&quot;name\&quot; - by the account name, ascending; \&quot;last-ecg\&quot; - by the ecg date/time, descending
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersGetPortalEcgList(userId: string, page?: number, pageSize?: number, fromDate?: string, toDate?: string, sort?: string, authorization?: string, options?: any): AxiosPromise<IShApiResponseListEcg>;

    /**
     * 
     * @summary Gets the list of Smartheart accounts the user has permissions to view in the Smartheart Portal.
     * @param {string} userId The unique identifier of the user whose permissions should be returned
     * @param {number} [page] The results \&quot;page\&quot; number to return
     * @param {number} [pageSize] The number of result in each \&quot;page\&quot;
     * @param {string} [sort] How to sort the returned permissions list (\&quot;name\&quot; - by the account name; \&quot;last-ecg\&quot; - by last ecg date/time
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersGetPortalPermissions(userId: string, page?: number, pageSize?: number, sort?: string, authorization?: string, options?: any): AxiosPromise<IShApiResponseListPortalPermission>;

    /**
     * 
     * @summary Gets the list of users in the logged api user organization.   Requires Api User role authorization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersGetUsers(options?: any): AxiosPromise<IShApiResponseIEnumerableSmartheartUser>;

    /**
     * 
     * @summary Authenticates a user
     * @param {ILoginData} credentials The username (email) and password of the user to authenticate
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersLogin(credentials: ILoginData, authorization?: string, options?: any): AxiosPromise<IShApiResponseFullSmartheartUser>;

    /**
     * 
     * @summary Updates the given user
     * @param {string} userId The unique identifier of the user to update
     * @param {IFullSmartheartUser} user The user data to update
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUpdateUser(userId: string, user: IFullSmartheartUser, authorization?: string, options?: any): AxiosPromise<IShApiResponseFullSmartheartUser>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * 
     * @summary Activates a given user based on a valid activation token and sets the given password to the activated user.
     * @param {IUserActivationData} activationData 
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersActivateUser(activationData: IUserActivationData, authorization?: string, options?: any) {
        return UsersApiFp(this.configuration).usersActivateUser(activationData, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds an additional email recipient for new ECG notifications
     * @param {string} userId The unique identifier of the user to add an additional recipient to
     * @param {IRecipient} recipient The recipient email address
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersAddRecipients(userId: string, recipient: IRecipient, authorization?: string, options?: any) {
        return UsersApiFp(this.configuration).usersAddRecipients(userId, recipient, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new user for an organization. The created user needs to be validated and/or activated
     * @param {IBasicSmartheartUser} user The user object to add
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreateOrganizationUser(user: IBasicSmartheartUser, authorization?: string, options?: any) {
        return UsersApiFp(this.configuration).usersCreateOrganizationUser(user, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new user
     * @param {IFullSmartheartUser} user The user object to add
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreateUser(user: IFullSmartheartUser, authorization?: string, options?: any) {
        return UsersApiFp(this.configuration).usersCreateUser(user, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes an email recipient for new ECG notifications
     * @param {string} userId The unique identifier of the user to remove the recipient from
     * @param {IRecipient} recipient The recipient email address to remove
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDeleteRecipient(userId: string, recipient: IRecipient, authorization?: string, options?: any) {
        return UsersApiFp(this.configuration).usersDeleteRecipient(userId, recipient, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disables the given user
     * @param {string} userId The unique identifier of the user
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDisableUser(userId: string, authorization?: string, options?: any) {
        return UsersApiFp(this.configuration).usersDisableUser(userId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enables a user
     * @param {string} userId The unique identifier of the user to enable
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersEnableUser(userId: string, authorization?: string, options?: any) {
        return UsersApiFp(this.configuration).usersEnableUser(userId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the list of ECGs to be viewed in the portal in a given date range of the permissions of the authenticated user.
     * @param {string} userId The unique identifier of the user whose portal ecg list should be returned
     * @param {number} [page] The results \&quot;page\&quot; number to return
     * @param {number} [pageSize] The number of result in each \&quot;page\&quot;
     * @param {string} [fromDate] The date from which to return the ECGs (yyyy-MM-dd)
     * @param {string} [toDate] The date until which to return the ECGs (yyyy-MM-dd)
     * @param {string} [sort] How to sort the returned ecgs list (\&quot;name\&quot; - by the account name, ascending; \&quot;last-ecg\&quot; - by the ecg date/time, descending
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGetPortalEcgList(userId: string, page?: number, pageSize?: number, fromDate?: string, toDate?: string, sort?: string, authorization?: string, options?: any) {
        return UsersApiFp(this.configuration).usersGetPortalEcgList(userId, page, pageSize, fromDate, toDate, sort, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the list of Smartheart accounts the user has permissions to view in the Smartheart Portal.
     * @param {string} userId The unique identifier of the user whose permissions should be returned
     * @param {number} [page] The results \&quot;page\&quot; number to return
     * @param {number} [pageSize] The number of result in each \&quot;page\&quot;
     * @param {string} [sort] How to sort the returned permissions list (\&quot;name\&quot; - by the account name; \&quot;last-ecg\&quot; - by last ecg date/time
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGetPortalPermissions(userId: string, page?: number, pageSize?: number, sort?: string, authorization?: string, options?: any) {
        return UsersApiFp(this.configuration).usersGetPortalPermissions(userId, page, pageSize, sort, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the list of users in the logged api user organization.   Requires Api User role authorization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGetUsers(options?: any) {
        return UsersApiFp(this.configuration).usersGetUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticates a user
     * @param {ILoginData} credentials The username (email) and password of the user to authenticate
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersLogin(credentials: ILoginData, authorization?: string, options?: any) {
        return UsersApiFp(this.configuration).usersLogin(credentials, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the given user
     * @param {string} userId The unique identifier of the user to update
     * @param {IFullSmartheartUser} user The user data to update
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdateUser(userId: string, user: IFullSmartheartUser, authorization?: string, options?: any) {
        return UsersApiFp(this.configuration).usersUpdateUser(userId, user, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}
